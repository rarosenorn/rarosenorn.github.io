<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rasmus Rosenørn - Algoritmer</title>
    <link rel="stylesheet" href="app.css" />
</head>

<body>

    <header>
        <span>Rasmus Rosenørn - Portefølje</span>
        <p> | </p>
        <nav>
            <ul>
                <li><a href="index.html">Projekt</a></li>
                <li><a href="blazor.html">Valgfag Blazor</a></li>
                <li><a href="algoritmer.html">Valgfag Algoritmer</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <h1>Valgfag - Algoritmer</h1>
        <h2>Litteraturliste</h2>
        <ul style="list-style-type: none;">
            <li><b>Bøger</b></li>
            <ul>
                <li>[B] Algorithms and Data Structures - Supplementary Lecture Notes</li>
                <li>[CLRS] Introduction to Algorithms (Fourth Edition)</li>
                <li>[S] Essential Algorithms</li>
            </ul>
            <li><b>Hjemmesider</b></li>
            <ul>
                Opgaver: https://www.hackerrank.com/
                Opgaver: https://leetcode.com/
            </ul>
            <li><b>Youtube Videoer</b></li>
            <ul>
                Dijkstras Algorithm: https://www.youtube.com/watch?v=GazC3A4OQTE&t=1s&ab_channel=Computerphile
                Mergesort: https://www.youtube.com/watch?v=3j0SWDX4AtU&t=394s&ab_channel=BroCode
                Heapsort: https://www.youtube.com/watch?v=2DmK_H7IdTo&t=191s&ab_channel=MichaelSambol
                Quicksort: https://www.youtube.com/watch?v=XE4VP_8Y0BU&ab_channel=Computerphile
                Countingsort: https://www.youtube.com/watch?v=7zuGmKfUt7s&ab_channel=GeeksforGeeks
                RedBlack trees: https://www.youtube.com/watch?v=qvZGUFHWChY&ab_channel=MichaelSambol
                

            </ul>
        </ul>
        <h2>Opgave - Formulering af læringsmål</h2>
        <h3>Opgave 1: Læringsmål for Algoritmer</h3>
        <h4>Beskrivelse af emne</h4>
        <p>I faget algoritmer læres om typer af datastrukturer og
            at løse forskellige typer af problemstillinger generisk gennem en række trin,
            hvor at disse trin udgør en algoritme. Jeg har valgt dette emne fordi
            det er nyttigt at kunne løse problemstillinger man møder på en effektiv måde
            og at man træner sin problemløsningsevne ved at lave algoritmeopgaver.
            Algoritmeopgaver bliver også ofte stillet som jobinterviewspørgsmål (formentlig
            ikke i Danmark i så stor grad)</p>
        <h4>Formulering af læringsmål</h4>
        <h5>Langsigtede læringsmål</h5>
        <ul class="learninggoals">
            <li>Viden</li>
            <li>
                <ul>
                    <li>Forståelse af teorien bag ofte brugte algoritmer</li>
                    <li>Forståelse af typer af tids- og rumkompleksiteter</li>
                    <li>Forstå og kunne forklare forskelle ved algoritmer der kan løse samme problemstilling</li>
                    <li>Forståelse af hvordan korrekte algoritmer påvirker en applikations effektivitet</li>
                    <li>Forståelse af typer af datastrukturer</li>
                </ul>
            </li>
            <li>Færdigheder</li>
            <li>
                <ul>
                    <li>Anvende en algoritme for at løse en given problemstilling</li>
                    <li>Anvende en algoritme i C#</li>
                    <li>Anvende hensigtsmæssig datastruktur</li>
                    <li>Anvende værktøj til at analysere en algoritmes kompleksitet</li>
                </ul>
            </li>
            <li>Kompetencer</li>
            <li>
                <ul>
                    <li>Identificere problemstilling der kræver algoritme</li>
                    <li>Identificere algoritme der løser given problemstilling</li>
                    <li>Tilegne sig ny viden omkring algoritmer for at løse problemstilling hvor der ikke kendes en løsning
                    </li>
                </ul>
            </li>
        </ul>
        <h5>Kortsigtede læringsmål</h5>
        <table class="tableclass">
            <thead>
                <tr>
                    <td>Uge</td>
                    <td>Læringsmål</td>
                    <td>Litteratur</td>
                    <td>Øvelser</td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>48</td>
                    <td>Fokus på færdiggørelse af projekt</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 48 log:
                    </td>
                </tr>
                <tr>
                    <td>47</td>
                    <td>graph algorithms</td>
                    <td>Read about in book [S]</td>
                    <td>Incoorporate and understand in project.</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 47 log:
                    </td>
                </tr>
                <tr>
                    <td>46</td>
                    <td>Graph algorithms</td>
                    <td>Read about in book [S]</td>
                    <td>Incoorporate and understand in project.</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 46 log: I read and incoorporated Dijkstras algorithm in my project. I have a chronic illness that in some period leaves me unable to do much, therefore 
                        I had to focus on finishing the project for the rest of the period.
                    </td>
                </tr>
                <tr>
                    <td>45</td>
                    <td>Greedy algorithms & graph algorithms</td>
                    <td>Read about in book [S]</td>
                    <td>Incoorporate and understand in project.</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 45 log: Greedy algorithms are algorithms that find the optimal solution by, at each step, choosing the best option, e.g. Dijkstras algorithm 
                        which finds the fastest path from node A to B given nodes and edges with weights.
                    </td>
                </tr>
                <tr>
                    <td>44</td>
                    <td>Divide & Conquer, Deterministic Selection</td>
                    <td>Read about in book [S]</td>
                    <td>Incoorporate and understand in project.</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 44 log: Divide and conquer is a method that is used in many algorithms, e.g. merge sort. The concept is dividing the
                        values into subarrays until atomized, then merge them and put them together into arrays that follows the wanted goal.
                    </td>
                </tr>
                <tr>
                    <td>43</td>
                    <td>Balanced search trees: Red-black trees, augmented search trees: Dynamic rank, interval trees, Fenwick trees</td>
                    <td>Read about the trees</td>
                    <td>Incoorporate and understand code in project</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 43 log: Fenwick trees are a tree to efficiently find the cumulative value, its more efficient than normal because
                        when inserting a value you have to update far less values than with a list. Red-black trees solve the problem of a normal binary search tree 
                        where time complexity of O(n) is possible for example with the root value of 10 and values of 15, 20, 25, 30 because they all go the right.
                    </td>
                </tr>
                <tr>
                    <td>42</td>
                    <td>Efterårsferie</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                </tr>

                <tr>
                    <td>41</td>
                    <td>Hashing and search trees</td>
                    <td>[CLRS] ch. 11.1-11.4 + 12 </td>
                    <td>[CLRS] ex. 11.1-2, 11.2-5, 11.4-1, 12.1-5, 12.2-4. p. 6-3</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 41 log: Hashing is a data structure where information is stored as key value pairs, where the value is accessed by the key.
                        Search trees are trees organized in a way that makes it more efficient to search for a value, binary search tree has a best case
                        time complexity of O(logn) because the possible values are halved each time. unbalanced binary search tree are structure such
                        that each node has a child that is less than to the left and greater than to the right. Searching you then look at the root
                        element and see if the search key is equal to, greater than or less than, if greater than you go to the right etc.
                    </td>
                </tr>
                <tr>
                    <td>40</td>
                    <td>Lower bound for comparison based sorting, counting sort, radix sort, bucket sort. Stacks and queues.</td>
                    <td>Læs om og forstå algoritmerne i [S]</td>
                    <td>Implementer algoritmer i C# kode og forstå</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 40 log: Counting sort: Tæl hvormange af hvert tal der er i array og skriv ned i nyt array hvor hvert index svarer
                        til tallet og tallet i indexet svarer til hvor mange af det tal der er. Derefter lav kumulative og så lav output array
                        hvor et index indsættes på indeksets værdis plads og værdien nedsættes med en,
                        til sidst har du det sorteret array. 
                        Radix sort: her sorterer man først tallene ind i grupper pr. 1s digit og sorterer disse gruppe, derefter sorterer man pr. 10s etc. indtil 
                        det højeste 'plads' Xs digit er sorterert, derefter konkatinerer man tallene og der er sorterert.
                        Bucket sort er relativt simpel, man propper elementer ned i buckets baseret på range, derefter sorterer man de 
                        enkelte buckets med e.g. insertion sort og så konkatinerer man bucketse igen.
                        Stacks og Queues er ret simple, en stack er LIFO, og queue er FIFO i.e. hhv. en stak tallerkener,
                        hvor den øverste tallerken der er sat ned sidst blive taget først og i et supermarked hvor det er først blev sat på hylden
                        gerne skulle tages først.
                    </td>
                </tr>
                <tr>
                    <td>39</td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 39 log: Var syg i denne uge, hvorfor ugeplaner er rykket 1 uge frem.
                    </td>
                </tr>
                <tr>
                    <td>38</td>
                    <td>Mergesort, heapsort, priority queues, quicksort, median, randomized selection</td>
                    <td>Læs om og forstå algoritmerne i [S]</td>
                    <td>Implementer algoritmer i C# kode og forstå</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 38 log: Bruger for lang tid på 'dybde opgaver' som eksempelvis beviser for algoritmer. Jeg har begrænset
                        energi grundet kronisk sygdom, hvorfor jeg begynder at fokusere på hvordan algoritmer virker, hvordan de implementeres
                        øve opgave og andre mere overfladiske aktiviteter som er mere direkte relevant ift. programmering. HeapSort fungerer ved
                        at heapify ved at lave et array til max heap hvor det er et binary tree hvor hver parent er mindst så stor som dets børn,
                        roden indsættes så ved det højeste index. Gentages med array.lenght - 2 etc..
                        Quicksort fungerer ved at vælge et pivot index og resten af arrayet sættes til højre eller venstre hhv. hvis det tallet
                        er større eller mindre. Derefter er pivot korrekt positioneret og der 2 subarrays rundt om pivot hvor der vælges et nyt
                        pivot og samme proces foretages. Til dette anvender jeg istedet bogen Essential Algorithms af Rod Stephens
                    </td>
                </tr>
                <tr>
                    <td>37</td>
                    <td>Induction, invariants, analysis tools, RAM model, insertion sort, O-notation</td>
                    <td>[B] 1.9-1.10 + 1.12 [CLRS] 1-3.2</td>
                    <td>[B] 1.13-1.16 + 1.18-1.19 [CLRS] ex. 1.2-2, 1.2-3, 3.2-1, 3.2-3 prb. 1-1, 3-3, 3-4(a-e)</td>
                </tr>
                <tr>
                    <td colspan="4">
                        Uge 37 log: Jeg syntes jeg bruger for meget tid på matematikopgaver(bevise at algoritmer slutter, deres tidskompleksitet etc.) 
                        og for lidt tid på at lære og forstå algoritmerne, hvorfor jeg i ugerne fremover vil springe nogle matematikopgaver over og
                        istedet lave specifikke algoritmeopgaver på e.g. leetcode og inkorporere i sideprojekter når jeg har lært dem. Stadig følge samme bog men mindre matematik
                        og mere hands on med algoritmer.
                    </td>
                </tr>
                <tr>
                    <td>36</td>
                    <td>Binær og lineær søgning, longest increasing subsequence, Erdos & Szekeres Theorem, logaritmer
                    </td>
                    <td>[B] 1.4-1.8</td>
                    <td>[B] 1.7-1.12</td>
                </tr>
                <tr>
                    <td colspan="4">Uge 36 log: Kom fint igennem stoffet på nær et afsnit og tilhørende øvelser som jeg laver næste uge.
                        Ift. feedback på øvelser kan jeg spørge chatGPT om jeg har lavet det korrekt eller give hints hvis jeg ikke kan løse opgaven.
                        Kan også bede den afklare afsnit som jeg er usikker på om jeg har forstået korrekt
                    </td>
                </tr>
                <tr>
                    <td>35</td>
                    <td>Grundlæggende forståelse for algoritmer og datastrukturer + selection sort + sorting with swaps</td>
                    <td>[B] 1.1-1.3</td>
                    <td>[B] 1.1-1.6</td>
                </tr>
                <tr>
                    <td colspan="4">Uge 35 log: Udfordrende men til at have med og gøre og kom igennem stoffet. God
                        introduktion til
                        at tænke algoritmisk. Ikke svar på exercises så kan ikke kontrollere om jeg har lavet dem
                        korrekt</td>
                </tr>
            </tbody>
        </table>
        <h3>Opgave 2 - Kvalitetskriterier</h3>
        <h4>Identifikation af kvalitetskriterier</h4>
        <ul>
            <li>Klarhed: klar beskrivelse af hvad der skal opnås</li>
            <li>Målbarhed: e.g. et bestemt kapitel skal forstås</li>
            <li>Tidsramme: klart defineret tidsramme for at opnå mål</li>
            <li>Mulighed for feedback: feedback om læringsmål er korrekt ift. e.g. scope og overordnede læringsmål</li>
        </ul>
        <h4>Anvendelse af kriterier</h4>
        <p>Anvendes som en "målestol" til at kontrollere kvaliteten af de læringsmål der bliver sat, så de kan laves
            om hvis de ikke er gode nok.</p>
        <h3>Opgave 4: Formidling</h3>
        <p>De kortsigtede mål understøtter de langsigtede mål ved at gøre dem konkrete
            med en handlingsplan der kan følges, e.g. de langsigtede læringsmål "Foreståelse af teorien bag ofte brugte
            algoritmer"
            og "Anvende en algoritme for at løse en given problemstilling" bliver gjort konkret i de kortsigtede
            læringsmål ved
            litteraturen og øvelserne der planlægges.</p>
    </main>~
</body>

</html>